# Neural Net Model Compiler & Optimizer

<p align="center"><img width="80%" src="../docs/images/modelCompilerWorkflow.png" /></p>

Neural Net Model Compiler & Optimizer converts pre-trained neural network models to MIVisionX runtime code for optimized inference.

Pre-trained models in [ONNX](https://onnx.ai/), [NNEF](https://www.khronos.org/nnef), & [Caffe](http://caffe.berkeleyvision.org/) formats are supported by the model compiler & optimizer. The model compiler first converts the pre-trained models to AMD Neural Net Intermediate Representation (NNIR), once the model has been translated into AMD NNIR (AMD's internal open format), the Optimizer goes through the NNIR and applies various optimizations which would allow the model to be deployed on to target hardware most efficiently. Finally, AMD NNIR is converted into OpenVX C code, which could be compiled and deployed on any targeted AMD hardware.

<p align="center"><img width="100%" src="../docs/images/frameworks.png" /></p>

## MIVisionX RunTime

MIVisionX allows hundreds of different [OpenVX](https://www.khronos.org/registry/OpenVX/specs/1.0/html/da/db6/group__group__vision__functions.html) and [OpenCV interop](../amd_openvx_extensions/amd_opencv#list-of-opencv-interop-kernels) vision functions to be directly added into the OpenVX C code generated by the model compiler & optimizer for preprocessing the input to the neural network model and post-processing the model results, hence allowing users to create an end to end solution to be deployed on any targeted AMD hardware.

<p align="center"><img width="100%" src="../docs/images/runtime.png" /></p>

## Pre-requisites
* MIVisionX libraries
* numpy
* onnx
````
% pip install onnx numpy
````

## Model Compiler & Optimizer Usage

### Step 1 - Convert Pre-trained model to AMD NNIR

To convert an ONNX model into AMD NNIR model:

```
% python onnx_to_nnir.py <model.onnx> <nnirModelFolder> [OPTIONS]

OPTIONS:
	--input_dims n,c,h,w
```

To convert a caffemodel into AMD NNIR model:

```
% python caffe_to_nnir.py <net.caffeModel> <nnirOutputFolder> --input-dims <n,c,h,w> [--verbose <0|1>]
```
### Step 2 - Apply Optimizations

To update batch size in AMD NNIR model:
````
% python nnir_update.py --batch-size <N> <nnirModelFolder> <nnirModelFolderN>
````

To fuse operations in AMD NNIR model (like batch normalization into convolution):
````
% python nnir_update.py --fuse-ops <1> <nnirModelFolderN> <nnirModelFolderFused>
````

To quantize the model to float 16
````
% python nnir_update.py --convert-fp16 <1> <nnirModelFolderN> <nnirModelFolderFused>
````

To workaround groups using slice and concat operations in AMD NNIR model:
````
% python nnir_update.py --slice-groups <1> <nnirModelFolderFused> <nnirModelFolderSliced>
````
### Step 3 - Convert AMD NNIR to OpenVX C code

To convert an AMD NNIR model into OpenVX C code:
````
% python nnir_to_openvx.py --help

Usage: python nnir_to_openvx.py [OPTIONS] <nnirInputFolder> <outputFolder>

  OPTIONS:
    --argmax UINT8                    -- argmax at the end with 8-bit output
    --argmax UINT16                   -- argmax at the end with 16-bit output
    --argmax <fileNamePrefix>rgb.txt  -- argmax at the end with RGB color mapping using LUT
    --argmax <fileNamePrefix>rgba.txt -- argmax at the end with RGBA color mapping using LUT
    --help                            -- show this help message

  LUT File Format (RGB): 8-bit R G B values one per each label in text format
    R0 G0 B0
    R1 G1 B1
    ...

  LUT File Format (RGBA): 8-bit R G B A values one per each label in text format
    R0 G0 B0 A0
    R1 G1 B1 A1
    ...
````
## Sample workflow of Model Compiler

### Trained Caffe Model conversion to AMD NNIR to OpenVX Graph

1. Convert net.caffemodel into NNIR model using the following command
   ````
	    % python caffe_to_nnir.py <net.caffeModel> <nnirOutputFolder> --input-dims n,c,h,w [--verbose 0|1]
   ````
2. Compile NNIR model into OpenVX C code with CMakelists.txt for compiling and building inference library
   ````
	    % python nnir_to_openvx.py <nnirModelFolder> <nnirModelOutputFolder>
   ````
3. cmake and make the project inside the nnirModelOutputFolder
   ````
	    % cd nnirModelOutputFolder
	    % cmake .
	    % make
   ````
4. Run anntest application for testing the inference with input and output tensor
   ````
	    % ./anntest weights.bin
   ````
5. The shared C library (libannmodule.so) can be used in any customer application

## Here are few examples of OpenVX C code generation

Generate OpenVX and test code that can be used dump and compare raw tensor data:
````
% python nnir_to_openvx.py nnirInputFolderFused openvxCodeFolder
% mkdir openvxCodeFolder/build
% cd openvxCodeFolder/build
% cmake ..
% make
% ./anntest

Usage: anntest <weights.bin> [<input-data-file(s)> [<output-data-file(s)>]]]

   <input-data-file>: is filename to initialize tensor
     .jpg or .png: decode and initialize for 3 channel tensors
         (use %04d in fileName to when batch-size > 1: batch index starts from 0)
     other: initialize tensor with raw data from the file

   <output-data-file>[,<reference-for-compare>,<maxErrorLimit>,<rmsErrorLimit>]:
     <referece-to-compare> is raw tensor data for comparision
     <maxErrorLimit> is max absolute error allowed
     <rmsErrorLimit> is max RMS error allowed
     <output-data-file> is filename for saving output tensor data
       '-' to ignore
       other: save raw tensor into the file

% ./anntest ../weights.bin input.f32 output.f32,reference.f32,1e-6,1e-9
...
````

Generate OpenVX and test code with argmax that can be used dump and compare 16-bit argmax output tensor:
````
% python nnir_to_openvx.py --argmax UINT16 nnirInputFolderFused openvxCodeFolder
% mkdir openvxCodeFolder/build
% cd openvxCodeFolder/build
% cmake ..
% make
% ./anntest

Usage: anntest <weights.bin> [<input-data-file(s)> [<output-data-file(s)>]]]

   <input-data-file>: is filename to initialize tensor
     .jpg or .png: decode and initialize for 3 channel tensors
         (use %04d in fileName to when batch-size > 1: batch index starts from 0)
     other: initialize tensor with raw data from the file

   <output-data-file>[,<reference-for-compare>,<percentErrorLimit>]:
     <referece-to-compare> is raw tensor data of argmax output for comparision
     <percentMismatchLimit> is max mismatch (percentage) allowed
     <output-data-file> is filename for saving output tensor data
       '-' to ignore
       other: save raw tensor into the file

% ./anntest ../weights.bin input-%04d.png output.u16,reference.u16,0.01
...
````

Generate OpenVX and test code with argmax and LUT that is designed for semantic segmentation use cases. You can dump output in raw format or PNGs and additionally compare with reference data in raw format.
````
% python nnir_to_openvx.py --argmax lut-rgb.txt nnirInputFolderFused openvxCodeFolder
% mkdir openvxCodeFolder/build
% cd openvxCodeFolder/build
% cmake ..
% make
% ./anntest

Usage: anntest <weights.bin> [<input-data-file(s)> [<output-data-file(s)>]]]

   <input-data-file>: is filename to initialize tensor
     .jpg or .png: decode and initialize for 3 channel tensors
         (use %04d in fileName to when batch-size > 1: batch index starts from 0)
     other: initialize tensor with raw data from the file

   <output-data-file>[,<reference-for-compare>,<percentErrorLimit>]:
     <referece-to-compare> is raw tensor data of LUT output for comparision
     <percentMismatchLimit> is max mismatch (percentage) allowed
     <output-data-file> is filename for saving output tensor data
       .png: save LUT output as PNG file(s)
         (use %04d in fileName when batch-size > 1: batch index starts from 0)
       '-' to ignore
       other: save raw tensor into the file

% ./anntest ../weights.bin input-%04d.png output.rgb,reference.rgb,0.01
...
% ./anntest ../weights.bin input-%04d.png output-%04d.png,reference.rgb,0.01
...
````
## Models & Operators currently supported
###  Models tested
Currently supporting below models from https://github.com/onnx/models with `release 1.1` tags
 - resnet50
 - googlenet
 - inception_v2
 - inception_v1
 - vgg19
 - densenet
 - squeezenet
 - zfnet

### Operators
Supported ONNX operators are:

- Conv
- Relu
- MaxPool
- AveragePool
- GlobalAveragePool
- LRN
- BatchNormalization
- Concat
- Sum
- Add
- Sub
- Mul
- Softmax
- Dropout
- Reshape

## License
Copyright (c) 2018 Advanced Micro Devices, Inc. All rights reserved.

Use of this source code is governed by the MIT License that can be found in the LICENSE file.
